// SPDX-License-Identifier: SEE LICENSE IN LICENSE.md
// SPDX-FileCopyrightText: 2023 CYBERTEC PostgreSQL International GmbH
// <office@cybertec.at>

//! Generated by `src/sourcegen/token.rs`, do not edit manually.

#[derive(logos :: Logos, Debug, Copy, Clone, PartialEq, Eq)]
pub enum TokenKind {
    #[regex("[ \t\n\r]+")]
    Whitespace,
    #[regex("--.*")]
    Comment,
    #[token("!", ignore(case))]
    Exclam,
    #[token("$$", ignore(case))]
    DollarQuote,
    #[token("%", ignore(case))]
    Percentage,
    #[token("(", ignore(case))]
    LParen,
    #[token("(+)", ignore(case))]
    OracleJoin,
    #[token(")", ignore(case))]
    RParen,
    #[token("*", ignore(case))]
    Asterisk,
    #[token("+", ignore(case))]
    Plus,
    #[token(",", ignore(case))]
    Comma,
    #[token("-", ignore(case))]
    Minus,
    #[token(".", ignore(case))]
    Dot,
    #[token("/", ignore(case))]
    Slash,
    #[token(":=", ignore(case))]
    Assign,
    #[token(";", ignore(case))]
    Semicolon,
    #[regex("=|<>|<|>|<=|>=")]
    Comparison,
    #[token("||", ignore(case))]
    DoublePipe,
    #[regex("-?\\d+", priority = 2)]
    Integer,
    #[regex("(?i)[a-z_][a-z0-9_$#]*", priority = 1)]
    UnquotedIdent,
    #[regex("\"(?:[^\"]|\"\")+\"")]
    QuotedIdent,
    #[regex("'[^']*'")]
    QuotedLiteral,
    #[token("create", ignore(case))]
    CreateKw,
    #[token("editionable", ignore(case))]
    EditionableKw,
    #[token("noneditionable", ignore(case))]
    NoneditionableKw,
    #[token("procedure", ignore(case))]
    ProcedureKw,
    #[token("function", ignore(case))]
    FunctionKw,
    #[token("replace", ignore(case))]
    ReplaceKw,
    #[token("declare", ignore(case))]
    DeclareKw,
    #[token("begin", ignore(case))]
    BeginKw,
    #[token("null", ignore(case))]
    NullKw,
    #[token("if", ignore(case))]
    IfKw,
    #[token("then", ignore(case))]
    ThenKw,
    #[token("elsif", ignore(case))]
    ElsifKw,
    #[token("else", ignore(case))]
    ElseKw,
    #[token("is", ignore(case))]
    IsKw,
    #[token("as", ignore(case))]
    AsKw,
    #[token("end", ignore(case))]
    EndKw,
    #[token("in", ignore(case))]
    InKw,
    #[token("out", ignore(case))]
    OutKw,
    #[token("nocopy", ignore(case))]
    NocopyKw,
    #[token("default", ignore(case))]
    DefaultKw,
    #[token("return", ignore(case))]
    ReturnKw,
    #[token("deterministic", ignore(case))]
    DeterministicKw,
    #[token("type", ignore(case))]
    TypeKw,
    #[token("select", ignore(case))]
    SelectKw,
    #[token("insert", ignore(case))]
    InsertKw,
    #[token("values", ignore(case))]
    ValuesKw,
    #[token("into", ignore(case))]
    IntoKw,
    #[token("from", ignore(case))]
    FromKw,
    #[token("where", ignore(case))]
    WhereKw,
    #[token("and", ignore(case))]
    AndKw,
    #[token("or", ignore(case))]
    OrKw,
    #[token("not", ignore(case))]
    NotKw,
    #[token("between", ignore(case))]
    BetweenKw,
    #[token("like", ignore(case))]
    LikeKw,
    #[token("ilike", ignore(case))]
    IlikeKw,
    #[token("interval", ignore(case))]
    IntervalKw,
    #[token("precision", ignore(case))]
    PrecisionKw,
    #[token("binary_float", ignore(case))]
    BinaryFloatKw,
    #[token("binary_double", ignore(case))]
    BinaryDoubleKw,
    #[token("nvarchar2", ignore(case))]
    Nvarchar2Kw,
    #[token("dec", ignore(case))]
    DecKw,
    #[token("integer", ignore(case))]
    IntegerKw,
    #[token("int", ignore(case))]
    IntKw,
    #[token("numeric", ignore(case))]
    NumericKw,
    #[token("smallint", ignore(case))]
    SmallintKw,
    #[token("number", ignore(case))]
    NumberKw,
    #[token("decimal", ignore(case))]
    DecimalKw,
    #[token("double", ignore(case))]
    DoubleKw,
    #[token("float", ignore(case))]
    FloatKw,
    #[token("real", ignore(case))]
    RealKw,
    #[token("nchar", ignore(case))]
    NcharKw,
    #[token("long", ignore(case))]
    LongKw,
    #[token("char", ignore(case))]
    CharKw,
    #[token("byte", ignore(case))]
    ByteKw,
    #[token("with", ignore(case))]
    WithKw,
    #[token("local", ignore(case))]
    LocalKw,
    #[token("time", ignore(case))]
    TimeKw,
    #[token("zone", ignore(case))]
    ZoneKw,
    #[token("set", ignore(case))]
    SetKw,
    #[token("character", ignore(case))]
    CharacterKw,
    #[token("varchar2", ignore(case))]
    Varchar2Kw,
    #[token("varchar", ignore(case))]
    VarcharKw,
    #[token("raw", ignore(case))]
    RawKw,
    #[token("date", ignore(case))]
    DateKw,
    #[token("rowid", ignore(case))]
    RowidKw,
    #[token("urowid", ignore(case))]
    UrowidKw,
    #[token("timestamp", ignore(case))]
    TimestampKw,
    #[token("bfile", ignore(case))]
    BfileKw,
    #[token("blob", ignore(case))]
    BlobKw,
    #[token("clob", ignore(case))]
    ClobKw,
    #[token("nclob", ignore(case))]
    NclobKw,
    #[token("varying", ignore(case))]
    VaryingKw,
    #[token("national", ignore(case))]
    NationalKw,
    #[token("to", ignore(case))]
    ToKw,
    #[token("year", ignore(case))]
    YearKw,
    #[token("month", ignore(case))]
    MonthKw,
    #[token("day", ignore(case))]
    DayKw,
    #[token("second", ignore(case))]
    SecondKw,
    #[error]
    Error,
    #[doc = r" Marker token to indicate end of input, not used by lexer directly."]
    Eof,
}
impl TokenKind {
    pub fn is_trivia(self) -> bool {
        matches!(self, Self::Whitespace | Self::Comment)
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            Self::Exclam
                | Self::DollarQuote
                | Self::Percentage
                | Self::LParen
                | Self::OracleJoin
                | Self::RParen
                | Self::Asterisk
                | Self::Plus
                | Self::Comma
                | Self::Minus
                | Self::Dot
                | Self::Slash
                | Self::Assign
                | Self::Semicolon
                | Self::Comparison
                | Self::DoublePipe
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            Self::Integer | Self::UnquotedIdent | Self::QuotedIdent | Self::QuotedLiteral
        )
    }
    pub fn is_ident(self) -> bool {
        matches!(self, Self::UnquotedIdent | Self::QuotedIdent)
            || !(self.is_trivia()
                || self.is_punct()
                || self.is_literal()
                || matches!(self, Self::Eof | Self::Error))
    }
}
impl std::fmt::Display for TokenKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}
macro_rules ! T { [whitespace] => { TokenKind :: Whitespace } ; [comment] => { TokenKind :: Comment } ; [!] => { TokenKind :: Exclam } ; ["$$"] => { TokenKind :: DollarQuote } ; [%] => { TokenKind :: Percentage } ; ["("] => { TokenKind :: LParen } ; [(+)] => { TokenKind :: OracleJoin } ; [")"] => { TokenKind :: RParen } ; [*] => { TokenKind :: Asterisk } ; [+] => { TokenKind :: Plus } ; [,] => { TokenKind :: Comma } ; [-] => { TokenKind :: Minus } ; [.] => { TokenKind :: Dot } ; [/] => { TokenKind :: Slash } ; [:=] => { TokenKind :: Assign } ; [;] => { TokenKind :: Semicolon } ; [comparison] => { TokenKind :: Comparison } ; [||] => { TokenKind :: DoublePipe } ; [int_literal] => { TokenKind :: Integer } ; [unquoted_ident] => { TokenKind :: UnquotedIdent } ; [quoted_ident] => { TokenKind :: QuotedIdent } ; [quoted_literal] => { TokenKind :: QuotedLiteral } ; [create] => { TokenKind :: CreateKw } ; [editionable] => { TokenKind :: EditionableKw } ; [noneditionable] => { TokenKind :: NoneditionableKw } ; [procedure] => { TokenKind :: ProcedureKw } ; [function] => { TokenKind :: FunctionKw } ; [replace] => { TokenKind :: ReplaceKw } ; [declare] => { TokenKind :: DeclareKw } ; [begin] => { TokenKind :: BeginKw } ; [null] => { TokenKind :: NullKw } ; [if] => { TokenKind :: IfKw } ; [then] => { TokenKind :: ThenKw } ; [elsif] => { TokenKind :: ElsifKw } ; [else] => { TokenKind :: ElseKw } ; [is] => { TokenKind :: IsKw } ; [as] => { TokenKind :: AsKw } ; [end] => { TokenKind :: EndKw } ; [in] => { TokenKind :: InKw } ; [out] => { TokenKind :: OutKw } ; [nocopy] => { TokenKind :: NocopyKw } ; [default] => { TokenKind :: DefaultKw } ; [return] => { TokenKind :: ReturnKw } ; [deterministic] => { TokenKind :: DeterministicKw } ; [type] => { TokenKind :: TypeKw } ; [select] => { TokenKind :: SelectKw } ; [insert] => { TokenKind :: InsertKw } ; [values] => { TokenKind :: ValuesKw } ; [into] => { TokenKind :: IntoKw } ; [from] => { TokenKind :: FromKw } ; [where] => { TokenKind :: WhereKw } ; [and] => { TokenKind :: AndKw } ; [or] => { TokenKind :: OrKw } ; [not] => { TokenKind :: NotKw } ; [between] => { TokenKind :: BetweenKw } ; [like] => { TokenKind :: LikeKw } ; [ilike] => { TokenKind :: IlikeKw } ; [interval] => { TokenKind :: IntervalKw } ; [precision] => { TokenKind :: PrecisionKw } ; [binary_float] => { TokenKind :: BinaryFloatKw } ; [binary_double] => { TokenKind :: BinaryDoubleKw } ; [nvarchar2] => { TokenKind :: Nvarchar2Kw } ; [dec] => { TokenKind :: DecKw } ; [integer] => { TokenKind :: IntegerKw } ; [int] => { TokenKind :: IntKw } ; [numeric] => { TokenKind :: NumericKw } ; [smallint] => { TokenKind :: SmallintKw } ; [number] => { TokenKind :: NumberKw } ; [decimal] => { TokenKind :: DecimalKw } ; [double] => { TokenKind :: DoubleKw } ; [float] => { TokenKind :: FloatKw } ; [real] => { TokenKind :: RealKw } ; [nchar] => { TokenKind :: NcharKw } ; [long] => { TokenKind :: LongKw } ; [char] => { TokenKind :: CharKw } ; [byte] => { TokenKind :: ByteKw } ; [with] => { TokenKind :: WithKw } ; [local] => { TokenKind :: LocalKw } ; [time] => { TokenKind :: TimeKw } ; [zone] => { TokenKind :: ZoneKw } ; [set] => { TokenKind :: SetKw } ; [character] => { TokenKind :: CharacterKw } ; [varchar2] => { TokenKind :: Varchar2Kw } ; [varchar] => { TokenKind :: VarcharKw } ; [raw] => { TokenKind :: RawKw } ; [date] => { TokenKind :: DateKw } ; [rowid] => { TokenKind :: RowidKw } ; [urowid] => { TokenKind :: UrowidKw } ; [timestamp] => { TokenKind :: TimestampKw } ; [bfile] => { TokenKind :: BfileKw } ; [blob] => { TokenKind :: BlobKw } ; [clob] => { TokenKind :: ClobKw } ; [nclob] => { TokenKind :: NclobKw } ; [varying] => { TokenKind :: VaryingKw } ; [national] => { TokenKind :: NationalKw } ; [to] => { TokenKind :: ToKw } ; [year] => { TokenKind :: YearKw } ; [month] => { TokenKind :: MonthKw } ; [day] => { TokenKind :: DayKw } ; [second] => { TokenKind :: SecondKw } ; [EOF] => { TokenKind :: Eof } ; }
pub(crate) use T;
