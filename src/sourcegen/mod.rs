// SPDX-License-Identifier: SEE LICENSE IN LICENSE.md
// SPDX-FileCopyrightText: 2023 CYBERTEC PostgreSQL International GmbH
// <office@cybertec.at>

//! Provides helper functions to facilitate code generation

mod data;
mod syntax;
mod token;

#[cfg(test)]
mod lib {
    use std::fs;
    use std::io::Write;
    use std::path::{Path, PathBuf};
    use std::process::{Command, Stdio};
    use std::str::from_utf8;

    /// Adds the license header and a edit warning preamble
    pub fn add_preamble(generator: &str, mut content: String) -> String {
        let preamble = format!(
            r#"// SPDX-License-Identifier: SEE LICENSE IN LICENSE.md
// SPDX-FileCopyrightText: 2023 CYBERTEC PostgreSQL International GmbH
// <office@cybertec.at>

//! Generated by `{generator}`, do not edit manually.

"#
        );
        content.insert_str(0, &preamble);
        content
    }

    /// Verifies that the `file` has the specified `content`.
    /// If not, it updates the file and fails the test.
    pub fn guarantee_file_content(file: &Path, content: &str) {
        // Check if the file is up-to-date.
        if let Ok(old_content) = fs::read_to_string(file) {
            if old_content == content {
                return;
            }
        }

        eprintln!("{} was not up-to-date, updating\n", file.display());

        if std::env::var("CI").is_ok() {
            eprintln!("NOTE: run `cargo test` locally and commit the generated files\n");
        }

        fs::write(file, content).unwrap();
        panic!("a file was not up-to-date and has been updated, re-run the tests");
    }

    /// Formats the specified `content` using the `rustfmt` binary
    pub fn rustfmt_content(content: String) -> String {
        let config_path = project_path().join(".rustfmt.toml");

        let mut cmd = Command::new("rustfmt")
            .arg("--config-path")
            .arg(config_path)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .expect("failed to spawn rustfmt");

        let cmd_stdin = cmd.stdin.as_mut().unwrap();
        cmd_stdin.write_all(content.as_bytes()).unwrap();

        let output = cmd.wait_with_output().unwrap();
        assert!(output.status.success());
        from_utf8(&output.stdout).unwrap().to_owned()
    }

    /// Returns the path of the project root
    pub fn project_path() -> PathBuf {
        let path = PathBuf::from(file!());
        let path = path.parent().unwrap().parent().unwrap().parent().unwrap();

        assert!(path.join("Cargo.toml").exists());

        path.to_owned()
    }
}
