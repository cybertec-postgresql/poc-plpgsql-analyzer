// SPDX-License-Identifier: SEE LICENSE IN LICENSE.md
// SPDX-FileCopyrightText: 2023 CYBERTEC PostgreSQL International GmbH
// <office@cybertec.at>

//! Specifies the token and syntax kinds to be generated

#[cfg(test)]
pub mod data {
    use crate::sourcegen::syntax::syntax::{SyntaxNode, S};
    use crate::sourcegen::token::token::{Tokens, T};

    pub(crate) const TOKENS: Tokens<'_> = Tokens {
        trivia: &[
            T!("whitespace", "whitespace", "whitespace", "[ \t\n\r]+"),
            T!("comment", "comment", "comment", "--.*"),
        ],
        punctuation: &[
            T!("!", "exclam", "exclam"),
            T!("$$", "dollar_quote", "dollar_quote"),
            T!("%", "percentage", "percentage"),
            T!("(", "l_paren", "l_paren"),
            T!("(+)", "oracle_join"),
            T!(")", "r_paren", "r_paren"),
            T!("*", "asterisk", "asterisk"),
            T!("+", "plus", "arithmetic_op"),
            T!(",", "comma", "comma"),
            T!("-", "minus", "arithmetic_op"),
            T!(".", "dot", "dot"),
            T!("/", "slash", "slash"),
            T!(":=", "assign", "assign"),
            T!(";", "semicolon", "semicolon"),
            T!(
                "comparison",
                "comparison",
                "comparison_op",
                "=|<>|<|>|<=|>="
            ),
            T!("||", "double_pipe", "concat"),
        ],
        literals: &[
            T!("int", "integer", "integer", r"-?\d+", 2),
            T!(
                "unquoted_ident",
                "unquoted_ident",
                "ident",
                r"(?i)[a-z_][a-z0-9_$#]*",
                1
            ),
            T!("quoted_ident", "quoted_ident", "ident", r#""(?:[^"]|"")+""#),
            T!(
                "quoted_literal",
                "quoted_literal",
                "quoted_literal",
                "'[^']*'"
            ),
        ],
        keywords: &[
            T!("create"),
            T!("editionable"),
            T!("noneditionable"),
            T!("procedure"),
            T!("function"),
            T!("replace"),
            T!("declare"),
            T!("begin"),
            T!("null"),
            T!("if"),
            T!("then"),
            T!("elsif"),
            T!("else"),
            T!("is"),
            T!("as"),
            T!("end"),
            T!("in"),
            T!("out"),
            T!("nocopy"),
            T!("default"),
            T!("return"),
            T!("deterministic"),
            T!("type"),
            T!("select"),
            T!("insert"),
            T!("values"),
            T!("into"),
            T!("from"),
            T!("where"),
            T!("and"),
            T!("or"),
            T!("not"),
            T!("between"),
            T!("like", "like", "comparison_op"),
            T!("ilike", "ilike", "comparison_op"),
            T!("interval"),
            T!("precision"),
            T!("binary_float"),
            T!("binary_double"),
            T!("nvarchar2"),
            T!("dec"),
            T!("integer"),
            T!("int"),
            T!("numeric"),
            T!("smallint"),
            T!("number"),
            T!("decimal"),
            T!("double"),
            T!("float"),
            T!("real"),
            T!("nchar"),
            T!("long"),
            T!("char"),
            T!("byte"),
            T!("with"),
            T!("local"),
            T!("time"),
            T!("zone"),
            T!("set"),
            T!("character"),
            T!("varchar2"),
            T!("varchar"),
            T!("raw"),
            T!("date"),
            T!("rowid"),
            T!("urowid"),
            T!("timestamp"),
            T!("bfile"),
            T!("blob"),
            T!("clob"),
            T!("nclob"),
            T!("varying"),
            T!("national"),
            T!("to"),
            T!("year"),
            T!("month"),
            T!("day"),
            T!("second"),
        ],
    };

    pub(crate) const SYNTAX_NODES: &'_ [SyntaxNode<'_>] =
        &[
            S!("l_paren", "Left Paren"),
            S!("r_paren", "Right Paren"),
            S!("percentage", "Percentage symbol"),
            S!("exclam", "An exclamation mark `!`"),
            S!("plus", "A plus `+`"),
            S!("minus", "A minus `-`"),
            S!("asterisk", "An asterisk `*`"),
            S!("slash", "Slash char `/`"),
            S!("and", "Logical operator AND"),
            S!("or", "Logical operator OR"),
            S!("not", "Unary logical operator NOT"),
            S!("comment", "Inline comment starting with `--`"),
            S!("whitespace", "Any whitespace character"),
            S!("keyword", "A SQL keyword, e.g. `CREATE`"),
            S!("ident_group", "An identifier group, consisting of multiple idents"),
            S!("ident", "An identifier, either quoted or unquoted"),
            S!("type_name", "A type name"),
            S!("dot", "A single dot"),
            S!("comma", "A single comma"),
            S!("semicolon", "A semi colon"),
            S!("colon", "A colon token"),
            S!("assign", "An Assign operator `:=`"),
            S!("concat", "A concatination operator `||`"),
            S!("datatype", "Any built-in oracle datatype"),
            S!("type_attribute", "A `%TYPE` attribute"),
            S!("integer", "Any integer, positive and negative"),
            S!("dollar_quote", "Single dollar quote `$$`"),
            S!("quoted_literal", "A single quoted literal"),
            S!("param", "A single Param node, consisting of name & type"),
            S!("param_list", "A node that consists of multiple parameters"),
            S!("procedure", "A node that marks a full CREATE [..] PROCEDURE block"),
            S!("procedure_header", "A node that marks a PROCEDURE header with params"),
            S!("block", "A node that marks a block"),
            S!("block_statement", "A node that marks an individual statement inside a block"),
            S!("declare_section", "A node that marks the declare section of a block"),
            S!("function_invocation", "An invocation of a function, from the identifier and the opening bracket to the closing bracket"),
            S!("argument_list", "A list of arguments inside a `FunctionInvocation`. Made of multiple `Arguments`, separated by commas"),
            S!("argument", "A singular argument inside an argument list"),
            S!("function", "A node that marks a full CREATE [..] FUNCTION block"),
            S!("function_header", "A node that marks a FUNCTION header with params and return type"),
            S!("select_stmt", "A node that marks a full SELECT statement"),
            S!("insert_stmt", "A node that marks a full INSERT statement"),
            S!("column_expr", "A single column expression, as part of an SELECT clause"),
            S!("select_clause", "A node that contains the whole SELECT clause of a query"),
            S!("into_clause", "A node that contains an `INTO` clause of a SELECT statement"),
            S!("where_clause", "Represent a complete `WHERE` clause expression"),
            S!("variable_decl", "A node that marks a variable declaration as part of a function or procedure"),
            S!("variable_decl_list", "A node that marks a list of variable declarations of functions and procedures"),
            S!("expression", "Holds a generic SQL logic/arithmetic expression"),
            S!("arithmetic_op", "Represents an arithmetic SQL operator (+, -, *, /)"),
            S!("comparison_op", "Represents an arithmetic SQL comparison operator (=, <>, <, >, <=, >=) or other types of comparison operators of SQL (ilike, like)"),
            S!("logic_op", "Represents a logical SQL operator (AND, OR, NOT)"),
            S!("text", "A text slice node"),
            S!("error", "An error token with a cause"),
            S!("root", "The root node element"),
        ];
}
